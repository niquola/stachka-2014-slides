Предметное программирование
===================

Когда становится сложно?
Когда все запутывается?

Как мы начинаем разрабатывать?
Нехватка концептуального фреймворка.

DDD for resque!


Bounded Contexts - обычно ваше приложение с
семантической точки зрения неоднородно.
Мы встречаем в нем понятия из разных областей.

## Проект Бармаглот

```
  Варкалось. Хливкие шорьки
  Пырялись по наве,
  И хрюкотали зелюки,
  Как мюмзики в мове.
```

##  Программирование это прикладная дисциплина

Программирование  и информатика это в основном прикладные дисциплины.
Мы их прикладываем к различным областям человеческой деятельности -
развлечение, общение, образование и обучение, торговля и медицина, в надежде
решить там какие либо проблемы или создать новые возможности.

Разрабатывая прикладные программы мы всегда оказываемся на границе двух или более областей
и обязаны их немного понимать, иначе все слишком легко довести до обсурда.
Мы это и инженеры и те для кого эта система разрабатывается - т.е. почти всегда оказывается,
что нет такого одного человека, который понимал бы и то и другое.

##  Предметная область

ПО у ПО может оказаться сложной. Может выясниться, что необходимо отучиться в вузе
(а потом еще и "теперь забудте все чему вас учили" поработать),
чтобы маломальски понимать ее и иметь приемлимую интуицию в этой области для принятия решений.

Байка про вентельки и сожженные ПК.

*  Семантический разрыв & энтропия

Как только интуиция и здравый смысл начинают вас подводить
ваша деятельность рискует превратиться в МУДУ (деятельность не приносящая ценности).
Вы даже можете начать причинять вред.
Один из принципов японской философии качества (Lean) - систематично уменьшать объем
такого рода деятельности.

## Induction vs Deduction

Есть два подхода:

* Bottom-Up - индуктивный (от частного к общему)
* Top-Down - дедуктивный (от общего к частному)

Дедуктивный яркий и быстрый (всем нравиться Шерлок Хомс),
Он позволет предсказать будущее.

Но в случае "сложной предметной области" не все обладают
подобным талантом - быстро и безошибочно находить правильную
модель (гипотезу).

## Premature modeling

Важно то как ваша система себя ведет, и во вторую очередь,
как она реализована. Use Cases это то на, что можно в начале опереться.

Проблема в том, что мы часто начинаем моделировать преждевременно.

> Преждевременное моделирование источник многих проблем ...

# Red-Green-Refactor


Как мы проектируем в ООП:

Мы описываем спецификацию (текстом).
Делаем первую реализацию.
Проходим тесты.
Дописываем новые.
Рефакторим реализацию.

# System Object

Вообще можно представить всю себе систему как один объект
(состояние и поведение).
Мы можем посывать ему сообщения (запросы и комманды), а
он нам на них отвечает.

# Use Case Driven (System object & CQRS )

Тогда интерфейс нашей системы-объекта можно описать Use Cases.
Use Case - последовательность взаимодействий с системой направленная
на достижение некоторой цели.

Вообще это богатая метафора, вокруг которой можно простроить архитектуру.

*  Прототипирование

Первая быстрая реализация такого объекта - может служить
работающим прототипом. Прототипирование позволяет сократить
цикл выяснения требований и уменьшить количество разработки "совсем не того".

*  Моделирование & бизнес локика (разные вещи)

Однако система растет в размере (как маленький слон).
И вы начнете сталкиваться с проблемами роста сложности.
И тут на помошь к нам приходит хорошая модель! Да мы не отменяем
моделирования, мы просто его откладываем до выяснения обстоятельств.
И когда обстоятельсв становиться достаточно мы можем найти хорошую
модель.

Но что такое хорошая модель?

Эта та модель, которая позволяет упростить реализацию! Часто такой
моделью становится модель близкая к предметной области (но не всегда).

##  DDD (system thinking) - bounded context - aggregate - entity/value_object

Это о ментальный фреймворк для моделирования.

Он дает вам in the large и in the small средства.

In the large:

Ubiquotus Language
Bounded Context
Context Map
Anticorupption Layer
Patterns:

In the small:

* Aggregates
* Entities & Value Ojbects
* TODO


Ваша система часто вынуждена обмениваться данными с другими системами.
Как минимум она обменивается ими с пользователями.

Грубо говоря обмен может быть двух типов:
Физически и семантический.

Физический (это как я дал бы вам свой жесткий диск) и сказал понимай как хочешь (там ext4:).
Семантический интероп - это когда ты понимаешь смысл передаваемой информации.
Но что значит понимать?
Нам нужны договоренности - стандарты!

Если вы работаете с действительно сложной и важной предметной областью, то в ней
уже наверное нашлись мудрые мужи, которые поняли ценность стандартов и базы знаний и начали их создавать
для этой области.

Поэтому начиная с какой-то степени проникновения в вашу предметную область
стоит поискать какие стандарты уже выработаны. Не объязательно их использовать на 100%,
но вы можете их изучить и применять частично. И по меньшей мере в них вы найдете хорошие и правильные названия
(а правильно называть очень сложная задача!). В хорошие стандарты вложено нечеловеческое количество
человеко лет!

Пример HL7 для медицины (dicom, snomed).

В каком формате хранятся знания?

Самый простой это справочники (классификации).
Потом терминологии и онтологии.

*  Семантика и интероп
*  Стандарты
*  Справочники/Терминологии
*  Онтологии
*  Простота
*  Синтетическая модель crunching to deeper insight
*  Место системы (Гедель)

